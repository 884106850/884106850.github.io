<!-- START OF FILE Paste February 17, 2026 - 3:45PM -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>æ™ºèƒ½æ‹¼è±†æ¿ Ultimate - Paint & Community</title>

<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<style>
    :root { 
        --bg: #0f0f12; 
        --panel: #18181b; 
        --panel-border: #27272a;
        --input-bg: #27272a;
        --text: #e4e4e7; 
        --text-mute: #a1a1aa;
        --accent: #8b5cf6; 
        --accent-hover: #7c3aed;
        --danger: #ef4444;
        --highlight: #facc15;
        --sidebar-width: 360px;
    }
    * { box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; user-select: none; }
    body { margin: 0; background: var(--bg); color: var(--text); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; height: 100vh; display: flex; overflow: hidden; }
    
    .sidebar { width: var(--sidebar-width); background: var(--panel); display: flex; flex-direction: column; border-right: 1px solid var(--panel-border); z-index: 200; box-shadow: 0 0 24px rgba(0,0,0,0.6); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); position: fixed; height: 100%; top: 0; }
    .sidebar.left { left: 0; border-right: 1px solid var(--panel-border); border-left: none; }
    .sidebar.left.collapsed { transform: translateX(-100%); }
    .sidebar.right { right: 0; border-left: 1px solid var(--panel-border); border-right: none; }
    .sidebar.right.collapsed { transform: translateX(100%); }
    
    .sidebar-toggle { position: absolute; top: 10px; width: 40px; height: 40px; background: var(--panel); border: 1px solid var(--panel-border); display: flex; justify-content: center; align-items: center; cursor: pointer; color: var(--accent); font-size: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); z-index: 201; font-family: monospace; }
    .sidebar.left .sidebar-toggle { right: -40px; border-left: none; border-radius: 0 8px 8px 0; }
    .sidebar.right .sidebar-toggle { left: -40px; border-right: none; border-radius: 8px 0 0 8px; }

    .switch-side-btn { position: absolute; top: 10px; right: 10px; padding: 4px 8px; font-size: 16px; background: transparent; border: none; color: var(--text-mute); cursor: pointer; z-index: 205; }
    
    .tabs { display: flex; background: #000; padding: 4px 4px 0 4px; border-bottom: 1px solid var(--panel-border); margin-right: 40px; }
    .tab { flex: 1; padding: 12px 0; text-align: center; cursor: pointer; color: var(--text-mute); font-size: 12px; border-radius: 6px 6px 0 0; transition: all 0.2s; font-weight: 600; position: relative; top: 1px; border: 1px solid transparent; }
    .tab.active { background: var(--panel); color: var(--accent); font-weight: 700; border-color: var(--panel-border); border-bottom-color: var(--panel); }
    
    .content { flex: 1; overflow-y: auto; padding: 16px; scrollbar-width: thin; scrollbar-color: #3f3f46 transparent; -webkit-overflow-scrolling: touch; }
    
    .group { background: var(--input-bg); padding: 12px; border-radius: 8px; margin-bottom: 12px; border: 1px solid rgba(255,255,255,0.03); }
    .group-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
    .group-title { font-size: 12px; color: var(--accent); font-weight: 700; display: flex; align-items: center; gap: 6px; letter-spacing: 0.5px; }
    
    .row { display: flex; gap: 8px; margin-bottom: 8px; align-items: center; width: 100%; }
    
    label { font-size: 11px; color: var(--text-mute); flex: 1; white-space: nowrap; font-weight: 500; }
    
    input[type="number"], input[type="text"], select { background: #121214; border: 1px solid #3f3f46; color: var(--text); padding: 5px; border-radius: 4px; width: 50px; text-align: center; font-size: 11px; }
    input[type="number"]:focus, input[type="text"]:focus { border-color: var(--accent); }
    select { width: auto; flex: 2; text-align: left; }
    
    .stepper { display: flex; align-items: center; background: #121214; border: 1px solid #3f3f46; border-radius: 4px; overflow: hidden; flex: 2; }
    .stepper button { width: 28px; height: 28px; padding: 0; background: transparent; border: none; color: var(--text-mute); font-size: 14px; cursor: pointer; }
    .stepper button:active { background: var(--accent); color: #fff; }
    .stepper input { border: none; background: transparent; width: 100%; height: 28px; padding: 0; border-left: 1px solid #3f3f46; border-right: 1px solid #3f3f46; border-radius: 0; font-weight: 600; }

    input[type="range"] { flex: 2; height: 4px; background: #3f3f46; border-radius: 2px; -webkit-appearance: none; }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: var(--accent); border-radius: 50%; margin-top: -5px; }

    button { background: #3f3f46; color: var(--text); border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; flex:1; font-size: 12px; font-weight: 600; display: inline-flex; justify-content: center; align-items: center; gap: 6px; }
    button:active { transform: translateY(1px); }
    button.primary { background: var(--accent); color: #fff; }
    button.active { background: #fff; color: #000; box-shadow: 0 0 12px rgba(255,255,255,0.4); }
    button.ghost { background: transparent; border: 1px solid #3f3f46; }

    .toggle-btn { background: #27272a; color: #666; border: 1px solid #3f3f46; flex: 2; text-align: center; cursor: pointer; transition: all 0.2s; border-radius: 20px; padding: 4px 10px; font-size: 11px; font-weight: 600; }
    .toggle-btn.active { background: var(--accent); color: white; border-color: var(--accent); box-shadow: 0 0 8px rgba(139, 92, 246, 0.3); }

    .d-pad { display: flex; flex-direction: column; align-items: center; gap: 4px; margin-top: 8px; background: #1f1f22; padding: 6px; border-radius: 8px; border: 1px solid #27272a; }
    .d-row { display: flex; gap: 4px; }
    .d-btn { width: 36px; height: 36px; padding: 0; flex: none; font-size: 14px; }

    /* Tool Palette */
    .tool-bar { display: flex; gap: 4px; background: #000; padding: 4px; border-radius: 8px; margin-bottom: 8px; border: 1px solid #333; }
    .tool-btn { flex: 1; padding: 6px; border-radius: 4px; cursor: pointer; text-align: center; font-size: 14px; background: #18181b; color: #888; border: 1px solid transparent; }
    .tool-btn.active { background: var(--accent); color: white; box-shadow: 0 2px 8px rgba(0,0,0,0.3); }
    
    .palette-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(56px, 1fr)); gap: 6px; margin-top: 12px; }
    .p-card { display: flex; flex-direction: column; align-items: center; background: #121214; padding: 4px; border-radius: 6px; cursor: pointer; border: 2px solid transparent; position: relative; }
    .p-card.active { border-color: var(--accent); background: #27272a; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    .p-card img, .p-card .color-preview { width: 100%; aspect-ratio: 1; border-radius: 4px; object-fit: cover; background: #000; margin-bottom: 4px; border: 1px solid #333; }
    .p-card input { width: 100%; font-size: 10px; background: transparent; border: none; color: var(--accent); font-weight: 700; padding: 0; text-align: center; }
    .p-count { font-size: 9px; color: var(--text-mute); margin-top: 2px; text-align: center; font-family: monospace; }

    .sample-box-container { margin-top: 10px; text-align: center; border: 1px solid #3f3f46; padding: 4px; border-radius: 6px; background: #000; display: flex; justify-content: center; }
    canvas.sample-canvas { position: static !important; cursor: crosshair; border: 1px solid #333; max-width: 100%; display: block; box-shadow: none !important; }

    .viewport { width: 100%; height: 100%; position: relative; background: #09090b; overflow: hidden; display: flex; justify-content: center; align-items: center; background-image: radial-gradient(#27272a 1px, transparent 1px); background-size: 20px 20px; touch-action: none; }
    #layer-img { position: absolute; top: 0; left: 0; image-rendering: pixelated; box-shadow: 0 0 50px rgba(0,0,0,0.5); transform-origin: 0 0; }
    #layer-phys { position: absolute; top: 0; left: 0; image-rendering: auto; transform-origin: 0 0; pointer-events: none; }

    /* Community Cards */
    .comm-card { background: #1f1f22; border: 1px solid #333; border-radius: 8px; padding: 10px; margin-bottom: 10px; display: flex; gap: 10px; cursor: pointer; transition: 0.2s; }
    .comm-card:hover { border-color: var(--accent); background: #27272a; }
    .comm-thumb { width: 80px; height: 80px; background: #000; border-radius: 4px; object-fit: contain; border: 1px solid #444; image-rendering: pixelated; }
    .comm-info { flex: 1; display: flex; flex-direction: column; justify-content: space-between; }
    .comm-title { font-size: 13px; font-weight: 700; color: var(--text); }
    .comm-stats { font-size: 10px; color: var(--text-mute); }
    .comm-colors { display: flex; gap: 2px; margin-top: 4px; flex-wrap: wrap; }
    .comm-c-dot { width: 12px; height: 12px; border-radius: 2px; border: 1px solid rgba(255,255,255,0.2); }
    
    .toast { position: absolute; top: 30px; left: 50%; transform: translateX(-50%); background: rgba(24, 24, 27, 0.95); padding: 10px 20px; border-radius: 50px; font-size: 12px; z-index: 2000; border: 1px solid var(--accent); color: var(--accent); display: none; box-shadow: 0 10px 30px rgba(0,0,0,0.5); backdrop-filter: blur(8px); pointer-events: none; }
    
    .progress-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 3000; display: none; flex-direction: column; justify-content: center; align-items: center; }
    .progress-box { width: 280px; background: #18181b; border: 1px solid #3f3f46; padding: 20px; border-radius: 12px; text-align: center; }
    .progress-bar-bg { width: 100%; height: 4px; background: #27272a; border-radius: 99px; margin: 16px 0; overflow: hidden; }
    .progress-bar-fill { height: 100%; background: var(--accent); width: 0%; transition: width 0.1s linear; }
    .progress-text { color: var(--text); font-size: 13px; font-weight: 600; }

    .controls-smart, .controls-fixed { display: none; }
    .mode-smart .controls-smart { display: block; }
    .mode-fixed .controls-fixed { display: block; }
</style>
</head>
<body>

<div id="progress-modal" class="progress-overlay"><div class="progress-box"><div class="progress-text">æ­£åœ¨åˆ†æ...</div><div class="progress-bar-bg"><div id="progress-fill" class="progress-bar-fill"></div></div><div id="progress-info" class="progress-detail">å‡†å¤‡ä¸­...</div></div></div>

<div class="sidebar left" id="sidebar">
    <div class="sidebar-toggle" onclick="app.toggleSidebar()">â‰¡</div>
    <button class="switch-side-btn" onclick="app.toggleSidebarSide()">â‡„</button>
    <div class="tabs">
        <div class="tab active" onclick="app.setMode('calib')">1.æ ¡å‡†</div>
        <div class="tab" onclick="app.setMode('analyze')">2.åˆ†æ</div>
        <div class="tab" onclick="app.setMode('play')">3.ä½œä¸š</div>
        <div class="tab" onclick="app.setMode('community')">4.ç¤¾åŒº</div>
    </div>

    <!-- 1. æ ¡å‡† -->
    <div id="panel-calib" class="content">
        <div class="group">
            <div class="group-header"><span class="group-title">ç‰©ç†åº•æ¿è§„æ ¼</span></div>
            <div class="row"><label>æ¨ªå‘æ ¼æ•°</label><div class="stepper"><button id="btn-pc-dec">-</button><input type="number" id="phys-cols" value="29" onchange="app.savePhys()"><button id="btn-pc-inc">+</button></div></div>
            <div class="row"><label>çºµå‘æ ¼æ•°</label><div class="stepper"><button id="btn-pr-dec">-</button><input type="number" id="phys-rows" value="29" onchange="app.savePhys()"><button id="btn-pr-inc">+</button></div></div>
            <div class="row"><label>ç½‘æ ¼çº¿å®½</label><div class="stepper"><button id="btn-pw-dec">-</button><input type="number" id="phys-weight" value="1" step="0.1" onchange="app.savePhys()"><button id="btn-pw-inc">+</button></div></div>
        </div>
        <div class="group">
            <div class="group-header"><span class="group-title">æŠ•å½±å¯¹é½</span></div>
            <div class="row"><button onclick="app.selAnchor(0)" id="cal-btn-0" class="ghost">â†– å·¦ä¸Š (TL)</button><button onclick="app.selAnchor(1)" id="cal-btn-1" class="ghost">â†˜ å³ä¸‹ (BR)</button></div>
            <div class="d-pad" style="margin-top:10px">
                <div style="font-size:10px; color:#666; margin-bottom:4px;">æ•´ä½“ç½‘æ ¼å¹³ç§»</div>
                <div class="d-row"><button class="d-btn primary" id="btn-nudge-up">â–²</button></div>
                <div class="d-row"><button class="d-btn" id="btn-nudge-left">â—€</button><button class="d-btn" id="btn-nudge-down">â–¼</button><button class="d-btn" id="btn-nudge-right">â–¶</button></div>
            </div>
        </div>
    </div>

    <!-- 2. åˆ†æ -->
    <div id="panel-analyze" class="content" style="display:none">
        <div class="group">
            <div class="group-header"><span class="group-title">ğŸ“‚ å›¾åƒæº</span></div>
            <input type="file" id="file-in" accept="image/*" style="width:100%; margin-bottom:12px; font-size:11px; color:#888;">
            <div class="row"><button onclick="app.flipImage()" id="btn-mirror" class="ghost">â†” é•œåƒç¿»è½¬</button><button onclick="app.clearAnalysis()" class="ghost" style="color: var(--text-mute);">ğŸ—‘ æ¸…é™¤æ ‡è®°</button></div>
        </div>
        <div class="group" id="analyze-group">
            <div class="group-header"><span class="group-title">ğŸ“ å…³é”®ç‚¹ä¸ç½‘æ ¼ (äº’æ–¥æ¨¡å¼)</span></div>
            <div class="row"><button onclick="app.setTargetMarker(0, false)" id="mk-btn-0">ğŸ” æ™ºèƒ½æ¢æµ‹ 1 (TL)</button><button onclick="app.setTargetMarker(1, false)" id="mk-btn-1">ğŸ” æ™ºèƒ½æ¢æµ‹ 2 (BR)</button></div>
            <div class="row"><button onclick="app.setTargetMarker(0, true)" id="mk-btn-fixed-0">ğŸ“Œ å›ºå®š 1 (TL)</button><button onclick="app.setTargetMarker(1, true)" id="mk-btn-fixed-1">ğŸ“Œ å›ºå®š 2 (BR)</button></div>
            <div style="border-top:1px solid rgba(255,255,255,0.05); margin: 12px 0;"></div>
            <button onclick="app.setBasePointMode()" id="btn-base-point" class="ghost" style="width:100%; margin-bottom:8px; border-style:dashed;">âš‘ è®¾ä¸ºåŸºå‡†ç‚¹ (0,0)</button>
            <div class="controls-smart">
                <div class="row"><label>å•å…ƒæ ¼è¾¹é•¿</label><div class="stepper"><button id="btn-cell-dec" title="ç¼©å°ä»¥å¸é™„">-</button><input type="number" id="val-cell-size" value="10" step="0.1" oninput="app.manualGrid()"><button id="btn-cell-inc" title="æ”¾å¤§ä»¥å¸é™„">+</button></div></div>
            </div>
            <div class="controls-fixed">
                <div class="row"><label>æ¨ªå‘è·¨åº¦</label><div class="stepper"><button id="btn-sx-dec">-</button><input type="number" id="span-x" value="1" oninput="app.manualGrid()"><button id="btn-sx-inc">+</button></div></div>
                <div class="row"><label>çºµå‘è·¨åº¦</label><div class="stepper"><button id="btn-sy-dec">-</button><input type="number" id="span-y" value="1" oninput="app.manualGrid()"><button id="btn-sy-inc">+</button></div></div>
                <div class="d-pad" style="margin-top:12px; background: rgba(0,0,0,0.2);"><div style="font-size:10px; color:#666; margin-bottom:4px;">å›ºå®šç‚¹å¾®è°ƒ</div><div class="d-row"><button class="d-btn primary" id="btn-fix-up">â–²</button></div><div class="d-row"><button class="d-btn" id="btn-fix-left">â—€</button><button class="d-btn" id="btn-fix-down">â–¼</button><button class="d-btn" id="btn-fix-right">â–¶</button></div></div>
            </div>
            <div style="border-top:1px solid rgba(255,255,255,0.05); margin: 12px 0;"></div>
            <div class="row"><label>ç½‘æ ¼çº¿å®½</label><div class="stepper"><button id="btn-gw-dec">-</button><input type="number" id="grid-width" value="2" min="1" step="1" oninput="app.render()"><button id="btn-gw-inc">+</button></div></div>
            <div class="row"><label>ç½‘æ ¼é¢œè‰²</label><input type="color" id="grid-color-an" value="#00ff00" onchange="app.render()" style="width:40px; height:24px; border:none; padding:0; background:none;"></div>
        </div>
        <div class="group">
            <div class="group-header"><span class="group-title">ğŸ¯ é‡‡æ ·åŒºåŸŸæ ¡å‡†</span></div>
            <button onclick="app.setSampleCellMode()" id="btn-select-sample" class="ghost" style="width:100%; margin-bottom:8px; font-size:11px;">ğŸ–Œï¸ é€‰å–æ ¡å‡†ç½‘æ ¼ (ç‚¹ç”»å¸ƒ)</button>
            <div style="font-size:10px; color:#aaa; margin-bottom:4px">é€‰ä¸­åç”»çº¢æ¡†å®šä¹‰å–è‰²åŒºï¼š</div>
            <div class="sample-box-container"><canvas id="sample-canvas" class="sample-canvas"></canvas></div>
            <button onclick="app.resetSampleRect()" class="ghost" style="margin-top:8px; font-size:10px;">é‡ç½®ä¸ºå…¨é€‰</button>
        </div>
    </div>

    <!-- 3. æ‹¼è±† -->
    <div id="panel-play" class="content" style="display:none">
        <div class="group" style="border-color: var(--accent);">
            <div class="group-header"><span class="group-title">ğŸš€ å…¨å±€åˆ†æ</span></div>
            <div class="row"><label>å¯ç”¨ OCR ä¿®æ­£</label><div class="toggle-btn" id="t-ocr" onclick="app.toggleSwitch('t-ocr')">å·²å…³é—­</div></div>
            <div class="row"><label>é‡‡æ ·ç®—æ³•</label><select id="algo-mode" style="background:#121214; color:white; border:1px solid #333; padding:4px; border-radius:4px; font-size:11px; flex:2;"><option value="rect-avg" selected>åŒºåŸŸå¹³å‡</option><option value="4-corner">å››è§’é‡‡æ ·</option><option value="4-edge">å››è¾¹ä¸­å¿ƒ</option><option value="8-point">å…«ç‚¹å¤åˆ</option><option value="16-point">16ç‚¹å¤åˆ (è‡ªåŠ¨å»å™ª)</option><option value="32-point">32ç‚¹å¤åˆ (è‡ªåŠ¨å»å™ª)</option><option value="64-point">64ç‚¹å¤åˆ (è‡ªåŠ¨å»å™ª)</option></select></div>
            <div class="row"><label>åº”ç”¨é‡‡æ ·çº¢æ¡†</label><div class="toggle-btn active" id="t-sample-rect" onclick="app.toggleSwitch('t-sample-rect')">å·²å¼€å¯</div></div>
            <div class="row" style="opacity:0.8; margin-top:8px;"><label>OCR æƒé‡</label><input type="range" id="ocr-weight" min="0" max="100" value="80"></div>
            <button class="primary" onclick="app.analyzeFeatures()" style="width:100%; margin-top:8px; height:40px; box-shadow:0 4px 12px rgba(139, 92, 246, 0.2);">ğŸ¨ å¼€å§‹å…¨å›¾åˆ†æ</button>
        </div>
        <div class="group">
            <div class="group-header"><span class="group-title">âœï¸ ç»˜å›¾å·¥å…·</span></div>
            <div class="tool-bar">
                <div class="tool-btn active" id="tool-move" onclick="app.setTool('move')" title="ç§»åŠ¨è§†å›¾">ğŸ–</div>
                <div class="tool-btn" id="tool-pen" onclick="app.setTool('pen')" title="ç”»ç¬” (å½“å‰è‰²)">âœï¸</div>
                <div class="tool-btn" id="tool-eraser" onclick="app.setTool('eraser')" title="æ©¡çš® (è¿˜åŸ)">ğŸ§¹</div>
                <div class="tool-btn" id="tool-picker" onclick="app.setTool('picker')" title="å–è‰²å™¨">ğŸ’‰</div>
                <div class="tool-btn" onclick="app.undo()" title="æ’¤é”€">â†©</div>
            </div>
            <div class="row"><label>å½“å‰ç”»ç¬”é¢œè‰²</label><input type="color" id="draw-color" value="#000000" onchange="app.setDrawColor(this.value)" style="width:40px; height:24px; border:none; padding:0; background:none;"></div>
        </div>
        <div class="group">
            <div class="group-header"><span class="group-title">ğŸ‘€ è§†è§‰è¾…åŠ©</span></div>
            <div class="row"><button onclick="app.togglePaletteMode()" id="btn-pal-mode" class="ghost" style="width:100%; font-size:11px;">æ˜¾ç¤ºï¼šåŸå›¾æˆªå›¾</button></div>
            <div class="row"><label>è‡ªå®šä¹‰é«˜äº®è‰²</label><div class="toggle-btn" id="t-hl" onclick="app.toggleSwitch('t-hl'); app.render();">å·²å…³é—­</div><input type="color" id="custom-hl-color" value="#00ff00" style="width:40px; height:24px; border:none; padding:0; background:none;" onchange="app.render()"></div>
            <div class="row"><label>ç½‘æ ¼é•œåƒ</label><div class="toggle-btn" id="t-mirror" onclick="app.toggleSwitch('t-mirror'); app.render();">å·²å…³é—­</div></div>
            <div class="row"><label>çŸ©é˜µæ¨¡å¼</label><div class="toggle-btn active" id="t-rect" onclick="app.toggleSwitch('t-rect'); app.render();">å·²å¼€å¯</div></div>
            <div class="row"><label>æ˜¾ç¤ºçº¹ç†</label><div class="toggle-btn" id="t-tex" onclick="app.toggleSwitch('t-tex'); app.render();">å·²å…³é—­</div></div>
            <div style="margin-top:8px"></div>
            <div class="row"><label>èƒŒæ™¯é®ç½©</label><input type="color" id="bg-color" value="#111111" onchange="app.render()"><label>ç½‘æ ¼çº¿</label><input type="color" id="grid-color" value="#333333" onchange="app.render()"></div>
            <label>å½¢çŠ¶è°ƒæ•´</label>
            <div class="row"><input type="range" id="shape-outer" min="10" max="100" value="100" oninput="app.render()"></div>
            <div class="row"><input type="range" id="shape-inner" min="0" max="95" value="0" oninput="app.render()"></div>
        </div>
        <div class="group">
            <div class="group-header"><span class="group-title">ğŸ—ºï¸ åŒºåŸŸå¯¼èˆª</span></div>
            <div class="d-pad" style="background:transparent; border:none; margin-top:0;"><div class="d-row"><button class="d-btn ghost" id="btn-page-up">â†‘</button></div><div class="d-row"><button class="d-btn ghost" id="btn-page-left">â†</button><button class="d-btn ghost" id="btn-page-down">â†“</button><button class="d-btn ghost" id="btn-page-right">â†’</button></div></div>
            <div style="text-align:center; margin-top:5px"><button id="page-display" class="ghost" style="width:100%; border-style:dashed; cursor:default">åŒºåŸŸ [0,0]</button></div>
            <div class="d-pad" style="margin-top:10px"><div style="font-size:10px; color:#666; margin-bottom:4px;">æ•´ä½“ç½‘æ ¼å¹³ç§»</div><div class="d-row"><button class="d-btn primary" id="btn-nudge-up-play">â–²</button></div><div class="d-row"><button class="d-btn" id="btn-nudge-left-play">â—€</button><button class="d-btn" id="btn-nudge-down-play">â–¼</button><button class="d-btn" id="btn-nudge-right-play">â–¶</button></div></div>
        </div>
        <div class="group">
            <div class="group-header"><span class="group-title">âš™ï¸ ç®—æ³•å¾®è°ƒ</span></div>
            <div class="row"><label>CIEDE2000</label><div class="toggle-btn" id="t-ciede" onclick="app.toggleSwitch('t-ciede'); app.render();">å·²å…³é—­</div></div>
            <div class="row"><label>è‰²å½©å®¹å·® (Î”E)</label><input type="range" id="tol-deltae" min="1" max="50" value="15"></div>
        </div>
        <div class="group"><button onclick="app.saveToCommunity()" class="primary" style="width:100%">ğŸ’¾ å‘å¸ƒå½“å‰å›¾çº¸åˆ°ç¤¾åŒº</button></div>
        <div id="palette-list" class="palette-container"></div>
        <!-- View Lock Control at bottom of Sidebar panel -->
        <div class="group" style="margin-top:20px; text-align:center;">
             <div class="toggle-btn active" id="view-lock-switch" onclick="app.toggleViewLock()" style="padding:10px;">ğŸ”’ è§†å£é”å®š</div>
             <div style="font-size:10px; color:#666; margin-top:4px">å¼€å¯åç¦æ­¢æ‹–æ‹½ç¼©æ”¾ï¼Œé˜²æ­¢è¯¯è§¦</div>
        </div>
    </div>

    <!-- 4. ç¤¾åŒº -->
    <div id="panel-community" class="content" style="display:none">
        <div class="group-header">
            <span class="group-title">ğŸ“š æœ¬åœ°å›¾çº¸åº“ (æ¨¡æ‹Ÿç¤¾åŒº)</span>
            <button onclick="app.toggleCommThumbMode()" id="btn-comm-mode" class="ghost" style="font-size:10px; width:auto; padding:4px;">å°é¢ï¼šåŸå›¾</button>
        </div>
        <div id="community-list"></div>
    </div>
</div>

<div class="viewport" id="vp">
    <canvas id="layer-img"></canvas>
    <canvas id="layer-phys"></canvas>
    <div id="toast" class="toast">æç¤º</div>
</div>

<script>
// ... (ColorTool & BEAD_DATA ä¿æŒä¸å˜) ...
var ColorTool = {
    rgb2lab: function(rgb) { var r=rgb[0]/255, g=rgb[1]/255, b=rgb[2]/255; r=r>0.04045?Math.pow((r+0.055)/1.055,2.4):r/12.92; g=g>0.04045?Math.pow((g+0.055)/1.055,2.4):g/12.92; b=b>0.04045?Math.pow((b+0.055)/1.055,2.4):b/12.92; var x=(r*0.4124+g*0.3576+b*0.1805)*100, y=(r*0.2126+g*0.7152+b*0.0722)*100, z=(r*0.0193+g*0.1192+b*0.9505)*100; x/=95.047; y/=100; z/=108.883; x=x>0.008856?Math.pow(x,1/3):7.787*x+16/116; y=y>0.008856?Math.pow(y,1/3):7.787*y+16/116; z=z>0.008856?Math.pow(z,1/3):7.787*z+16/116; return [116*y-16, 500*(x-y), 200*(y-z)]; },
    deltaE: function(l1, l2) { return Math.sqrt(Math.pow(l1[0]-l2[0],2) + Math.pow(l1[1]-l2[1],2) + Math.pow(l1[2]-l2[2],2)); },
    preprocessForOCR: function(srcCanvas) { var scale=4; var w=srcCanvas.width*scale; var h=srcCanvas.height*scale; var out=document.createElement('canvas'); out.width=w+20; out.height=h+20; var octx=out.getContext('2d'); octx.fillStyle="#FFFFFF"; octx.fillRect(0,0,out.width,out.height); octx.imageSmoothingEnabled=true; octx.drawImage(srcCanvas,0,0,srcCanvas.width,srcCanvas.height,10,10,w,h); var imgData=octx.getImageData(0,0,out.width,out.height); var d=imgData.data; for(var i=0;i<d.length;i+=4){ var v=(d[i]+d[i+1]+d[i+2])/3; v=v<160?0:255; d[i]=d[i+1]=d[i+2]=v; } octx.putImageData(imgData,0,0); return out.toDataURL('image/png'); }
};
var BEAD_DATA=[["A1","#FAF4C8"],["A10","#F77C31"],["A11","#FFDD99"],["A12","#FE9F72"],["A13","#FFC365"],["A14","#FD543D"],["A15","#FFF365"],["A16","#FFFF9F"],["A17","#FFE36E"],["A18","#FEBE7D"],["A19","#FD7C72"],["A2","#FFFFD5"],["A20","#FFD568"],["A21","#FFE395"],["A22","#F4F57D"],["A23","#E6C9B7"],["A24","#F7F8A2"],["A25","#FFD67D"],["A26","#FFC830"],["A3","#FEFF8B"],["A4","#FBED56"],["A5","#F4D738"],["A6","#FEAC4C"],["A7","#FE8B4C"],["A8","#FFDA45"],["A9","#FF995B"],["B1","#E6EE31"],["B10","#95D3C2"],["B11","#5D722A"],["B12","#166F41"],["B13","#CAEB7B"],["B14","#ADE946"],["B15","#2E5132"],["B16","#C5ED9C"],["B17","#9BB13A"],["B18","#E6EE49"],["B19","#24B88C"],["B2","#63F347"],["B20","#C2F0CC"],["B21","#156A6B"],["B22","#0B3C43"],["B23","#303A21"],["B24","#EEFCA5"],["B25","#4E846D"],["B26","#8D7A35"],["B27","#CCE1AF"],["B28","#9EE5B9"],["B29","#C5E254"],["B3","#9EF780"],["B30","#E2FCB1"],["B31","#B0E792"],["B32","#9CAB5A"],["B4","#5DE035"],["B5","#35E352"],["B6","#65E2A6"],["B7","#3DAF80"],["B8","#1C9C4F"],["B9","#27523A"],["C1","#E8FFE7"],["C10","#3EBCE2"],["C11","#28DDDE"],["C12","#1C334D"],["C13","#CDE8FF"],["C14","#D5FDFF"],["C15","#22C4C6"],["C16","#1557A8"],["C17","#04D1F6"],["C18","#1D3344"],["C19","#1887A2"],["C2","#A9F9FC"],["C20","#176DAF"],["C21","#BEDDFF"],["C22","#67B4BE"],["C23","#C8E2FF"],["C24","#7CC4FF"],["C25","#A9E5E5"],["C26","#3CAED8"],["C27","#D3DFFA"],["C28","#BBCFED"],["C29","#34488E"],["C3","#A0E2FB"],["C4","#41CCFF"],["C5","#01ACEB"],["C6","#50AAF0"],["C7","#3677D2"],["C8","#0F54C0"],["C9","#324BCA"],["D1","#AEB4F2"],["D10","#361851"],["D11","#B9BAE1"],["D12","#DE9AD4"],["D13","#B90095"],["D14","#8B279B"],["D15","#2F1F90"],["D16","#E3E1EE"],["D17","#C4D4F6"],["D18","#A45EC7"],["D19","#D8C3D7"],["D2","#858EDD"],["D20","#9C32B2"],["D21","#9A009B"],["D22","#333A95"],["D23","#EBDAFC"],["D24","#7786E5"],["D25","#494FC7"],["D26","#DFC2F8"],["D3","#2F54AF"],["D4","#182A84"],["D5","#B843C5"],["D6","#AC7BDE"],["D7","#8854B3"],["D8","#E2D3FF"],["D9","#D5B9F8"],["E1","#FDD3CC"],["E10","#D33793"],["E11","#FCDDD2"],["E12","#F78FC3"],["E13","#B5006D"],["E14","#FFD1BA"],["E15","#F8C7C9"],["E16","#FFF3EB"],["E17","#FFE2EA"],["E18","#FFC7DB"],["E19","#FEBAD5"],["E2","#FEC0DF"],["E20","#D8C7D1"],["E21","#BD9DA1"],["E22","#B785A1"],["E23","#937A8D"],["E24","#E1BCE8"],["E3","#FFB7E7"],["E4","#E8649E"],["E5","#F551A2"],["E6","#F13D74"],["E7","#C63478"],["E8","#FFDBE9"],["E9","#E970CC"],["F1","#FD957B"],["F10","#8A4526"],["F11","#5A2121"],["F12","#FD4E6A"],["F13","#F35744"],["F14","#FFA9AD"],["F15","#D30022"],["F16","#FEC2A6"],["F17","#E69C79"],["F18","#D37C46"],["F19","#C1444A"],["F2","#FC3D46"],["F20","#CD9391"],["F21","#F7B4C6"],["F22","#FDC0D0"],["F23","#F67E66"],["F24","#E698AA"],["F25","#E54B4F"],["F3","#F74941"],["F4","#FC283C"],["F5","#E7002F"],["F6","#943630"],["F7","#971937"],["F8","#BC0028"],["F9","#E2677A"],["G1","#FFE2CE"],["G10","#D98C39"],["G11","#E0C593"],["G12","#FFC890"],["G13","#B7714A"],["G14","#8D614C"],["G15","#FCF9E0"],["G16","#F2D9BA"],["G17","#78524B"],["G18","#FFE4CC"],["G19","#E07935"],["G2","#FFC4AA"],["G20","#A94023"],["G21","#B88558"],["G3","#F4C3A5"],["G4","#E1B383"],["G5","#EDB045"],["G6","#E99C17"],["G7","#9D5B3E"],["G8","#753832"],["G9","#E6B483"],["H1","#FDFBFF"],["H10","#EEE9EA"],["H11","#CECDD5"],["H12","#FFF5ED"],["H13","#F5ECD2"],["H14","#CFD7D3"],["H15","#98A6A8"],["H16","#1D1414"],["H17","#F1EDED"],["H18","#FFFDF0"],["H19","#F6EFE2"],["H2","#FEFFFF"],["H20","#949FA3"],["H21","#FFFBE1"],["H22","#CACAD4"],["H23","#9A9D94"],["H3","#B6B1BA"],["H4","#89858C"],["H5","#48464E"],["H6","#2F2B2F"],["H7","#000000"],["H8","#E7D6DB"],["H9","#EDEDED"],["M1","#BCC6B8"],["M10","#C5B2BC"],["M11","#9F7594"],["M12","#644749"],["M13","#D19066"],["M14","#C77362"],["M15","#757D78"],["M2","#8AA386"],["M3","#697D80"],["M4","#E3D2BC"],["M5","#D0CCAA"],["M6","#B0A782"],["M7","#B4A497"],["M8","#B38281"],["M9","#A58767"],["P1","#FCF7F8"],["P10","#D9C7EA"],["P11","#F3ECC9"],["P12","#E6EEF2"],["P13","#AACBEF"],["P14","#337680"],["P15","#668575"],["P16","#FEBF45"],["P17","#FEA324"],["P18","#FEB89F"],["P19","#FFFEEC"],["P2","#B0A9AC"],["P20","#FEBECF"],["P21","#ECBEBF"],["P22","#E4A89F"],["P23","#A56268"],["P3","#AFDCAB"],["P4","#FEA49F"],["P5","#EE8C3E"],["P6","#5FD0A7"],["P7","#EB9270"],["P8","#F0D958"],["P9","#D9D9D9"],["Q1","#F2A5E8"],["Q2","#E9EC91"],["Q3","#FFFF00"],["Q4","#FFEBFA"],["Q5","#76CEDE"],["R1","#D50D21"],["R10","#FFDB4C"],["R11","#FFEBFA"],["R12","#D8D5CE"],["R13","#55514C"],["R14","#9FE4DF"],["R15","#77CEE9"],["R16","#3ECFCA"],["R17","#4A867A"],["R18","#7FCD9D"],["R19","#CDE55D"],["R2","#F92F83"],["R20","#E8C7B4"],["R21","#AD6F3C"],["R22","#6C372F"],["R23","#FEB872"],["R24","#F3C1C0"],["R25","#C9675E"],["R26","#D293BE"],["R27","#EA8CB1"],["R28","#9C87D6"],["R3","#FD8324"],["R4","#F8EC31"],["R5","#35C75B"],["R6","#238891"],["R7","#19779D"],["R8","#1A60C3"],["R9","#9A56B4"],["T1","#FFFFFF"],["Y1","#FD6FB4"],["Y2","#FEB481"],["Y3","#D7FAA0"],["Y4","#8BDBFA"],["Y5","#E987EA"],["ZG1","#DAABB3"],["ZG2","#D6AA87"],["ZG3","#C1BD8D"],["ZG4","#96869F"],["ZG5","#8490A6"],["ZG6","#94BFE2"],["ZG7","#E2A9D2"],["ZG8","#AB91C0"] ];

function App() {
    var self = this;
    this.beads = BEAD_DATA.map(function(it) {
        var r=parseInt(it[1].slice(1,3),16), g=parseInt(it[1].slice(3,5),16), b=parseInt(it[1].slice(5,7),16);
        return { id:it[0], hex:it[1], lab:ColorTool.rgb2lab([r,g,b]) };
    });
    this.vp = document.getElementById('vp');
    this.ctx = { img: document.getElementById('layer-img').getContext('2d'), phys: document.getElementById('layer-phys').getContext('2d'), smp: document.getElementById('sample-canvas').getContext('2d') };
    this.state = { mode:'calib', img:null, view:{x:20, y:20, scale:0.8}, drag:{active:false}, waitClick:false, activeAnchor:0, targetMarker:-1, targetMarkerFixed:false, activeFixedMarker:-1, waitingForFixedPos:false, isSidebarOpen:true, waitingForBasePoint:false, isMirrored:false, sampleRect:null, sampleDraw:{active:false}, waitingForSampleCell:false, sampleCellOffset:null, paletteMode:'image', viewMode:'locked', tool:'move', drawColor:'#000000', commThumbMode:'image' };
    
    // Data Storage
    this.phys = JSON.parse(localStorage.getItem('perler_final_v12') || '{"anchors":[{"x":100,"y":100},{"x":500,"y":500}],"cols":29,"rows":29,"weight":1}');
    this.markers = [];
    this.grid = { ready:false, origin:{x:0,y:0}, pitch:11.0, gap:0, cell:10, fixed:false, baseOffset:{c:0,r:0} }; 
    this.page = { x:0, y:0 };
    this.clusters = [];
    this.activeClusterIdx = -1;
    this.mods = {}; // Modifications map: "c,r" -> hex
    this.history = []; // Undo stack

    this.isChecked = function(id) { 
        var el = document.getElementById(id);
        if(!el) return false;
        if(el.classList.contains('toggle-btn')) return el.classList.contains('active');
        return el.checked; 
    };
    this.getVal = function(id) { var el = document.getElementById(id); return el ? el.value : 0; };

    this.toggleSwitch = function(id) {
        var el = document.getElementById(id);
        el.classList.toggle('active');
        if(el.classList.contains('active')) el.innerText = "å·²å¼€å¯"; else el.innerText = "å·²å…³é—­";
    };
    
    this.toggleViewLock = function() {
        var el = document.getElementById('view-lock-switch');
        el.classList.toggle('active');
        this.state.viewMode = el.classList.contains('active') ? 'locked' : 'free';
        if(this.state.viewMode === 'locked') {
            el.innerText = "ğŸ”’ è§†å£é”å®š";
            this.resetView();
        } else {
            el.innerText = "ğŸ– è‡ªç”±ç¼©æ”¾";
        }
    };
    
    this.resetView = function() {
        if(this.state.img) {
            var vw = this.vp.offsetWidth, vh = this.vp.offsetHeight;
            var s = Math.min((vw-40)/this.state.img.width, (vh-40)/this.state.img.height);
            this.state.view.scale = s;
            this.state.view.x = (vw - this.state.img.width*s)/2;
            this.state.view.y = (vh - this.state.img.height*s)/2;
            this.render();
        }
    };

    this.init = function() {
        window.onresize = function(){ self.resize(); };
        this.resize();
        document.getElementById('phys-cols').value = this.phys.cols;
        document.getElementById('phys-rows').value = this.phys.rows;
        document.getElementById('phys-weight').value = this.phys.weight || 1;
        this.loadCommunity(); 

        document.getElementById('file-in').onchange = function(e) {
            var f = e.target.files[0];
            if(f) {
                var r = new FileReader(); r.onload=function(ev){
                    var img=new Image(); img.onload=function(){
                        self.state.img=img; 
                        self.state.isMirrored = false;
                        self.clearAnalysis();
                        self.clusters = [];
                        self.mods = {};
                        self.history = [];
                        self.renderPaletteGroups();
                        document.getElementById('btn-mirror').classList.remove('active');
                        self.tmpCanvas = null; 
                        self.resetView();
                    }; img.src=ev.target.result;
                }; r.readAsDataURL(f);
            }
        };
        
        // Touch / Mouse Events
        this.vp.addEventListener('mousedown', function(e){ self.handleStart(e.clientX, e.clientY); });
        this.vp.addEventListener('touchstart', function(e){ 
            if(e.touches.length===1) self.handleStart(e.touches[0].clientX, e.touches[0].clientY);
            else if(e.touches.length===2) self.handlePinchStart(e);
        }, {passive:false});
        
        window.addEventListener('mousemove', function(e){ self.handleMove(e.clientX, e.clientY); });
        window.addEventListener('touchmove', function(e){ 
            if(e.target.closest('.viewport')) {
                e.preventDefault(); 
                if(e.touches.length===1) self.handleMove(e.touches[0].clientX, e.touches[0].clientY);
                else if(e.touches.length===2) self.handlePinchMove(e);
            }
        }, {passive:false});
        
        window.addEventListener('mouseup', function(e){ self.handleEnd(e); });
        window.addEventListener('touchend', function(e){ self.handleEnd(e); });
        
        this.vp.onwheel = function(e){ e.preventDefault(); var s=e.deltaY<0?1.1:0.9; self.zoomAt(e.clientX, e.clientY, s); };
        
        var smpCvs = document.getElementById('sample-canvas');
        smpCvs.onmousedown = function(e){ self.sampleStart(e); };
        smpCvs.onmousemove = function(e){ self.sampleMove(e); };
        smpCvs.onmouseup = function(e){ self.sampleEnd(e); };
        
        // Bindings...
        this.bindRepeater('btn-nudge-up', function(){ app.nudgeBoth(0,-1); });
        this.bindRepeater('btn-nudge-down', function(){ app.nudgeBoth(0,1); });
        this.bindRepeater('btn-nudge-left', function(){ app.nudgeBoth(-1,0); });
        this.bindRepeater('btn-nudge-right', function(){ app.nudgeBoth(1,0); });
        
        this.bindRepeater('btn-nudge-up-play', function(){ app.nudgeBoth(0,-1); });
        this.bindRepeater('btn-nudge-down-play', function(){ app.nudgeBoth(0,1); });
        this.bindRepeater('btn-nudge-left-play', function(){ app.nudgeBoth(-1,0); });
        this.bindRepeater('btn-nudge-right-play', function(){ app.nudgeBoth(1,0); });
        
        this.bindRepeater('btn-fix-up', function(){ app.nudgeFixed(0,-1); });
        this.bindRepeater('btn-fix-down', function(){ app.nudgeFixed(0,1); });
        this.bindRepeater('btn-fix-left', function(){ app.nudgeFixed(-1,0); });
        this.bindRepeater('btn-fix-right', function(){ app.nudgeFixed(1,0); });
        
        this.bindRepeater('btn-page-up', function(){ app.changePage(0,-1); });
        this.bindRepeater('btn-page-down', function(){ app.changePage(0,1); });
        this.bindRepeater('btn-page-left', function(){ app.changePage(-1,0); });
        this.bindRepeater('btn-page-right', function(){ app.changePage(1,0); });
        
        this.bindRepeater('btn-cell-dec', function(){ app.jumpCellSize(-1); });
        this.bindRepeater('btn-cell-inc', function(){ app.jumpCellSize(1); });
        this.bindRepeater('btn-gap-dec', function(){ });
        this.bindRepeater('btn-gap-inc', function(){ });
        
        this.bindRepeater('btn-pc-dec', function(){ app.stepInput('phys-cols',-1); app.savePhys(); });
        this.bindRepeater('btn-pc-inc', function(){ app.stepInput('phys-cols',1); app.savePhys(); });
        this.bindRepeater('btn-pr-dec', function(){ app.stepInput('phys-rows',-1); app.savePhys(); });
        this.bindRepeater('btn-pr-inc', function(){ app.stepInput('phys-rows',1); app.savePhys(); });
        this.bindRepeater('btn-pw-dec', function(){ app.stepInput('phys-weight',-0.1); app.savePhys(); });
        this.bindRepeater('btn-pw-inc', function(){ app.stepInput('phys-weight',0.1); app.savePhys(); });
        
        this.bindRepeater('btn-sx-dec', function(){ app.stepInput('span-x',-1); app.manualGrid(); });
        this.bindRepeater('btn-sx-inc', function(){ app.stepInput('span-x',1); app.manualGrid(); });
        this.bindRepeater('btn-sy-dec', function(){ app.stepInput('span-y',-1); app.manualGrid(); });
        this.bindRepeater('btn-sy-inc', function(){ app.stepInput('span-y',1); app.manualGrid(); });
        
        this.bindRepeater('btn-gw-dec', function(){ app.stepInput('grid-width',-1); app.render(); });
        this.bindRepeater('btn-gw-inc', function(){ app.stepInput('grid-width',1); app.render(); });

        this.render();
    };

    // Painting Tools
    this.setTool = function(t) {
        this.state.tool = t;
        ['move','pen','eraser','picker'].forEach(function(k){
            document.getElementById('tool-'+k).classList.remove('active');
        });
        document.getElementById('tool-'+t).classList.add('active');
    };
    
    this.setDrawColor = function(c) {
        this.state.drawColor = c;
    };
    
    this.pushHistory = function() {
        if(this.history.length > 20) this.history.shift();
        this.history.push(JSON.stringify(this.mods));
    };
    
    this.undo = function() {
        if(this.history.length > 0) {
            this.mods = JSON.parse(this.history.pop());
            this.render();
        }
    };
    
    this.applyMod = function(c, r) {
        if(this.state.tool === 'pen') {
            this.mods[c+','+r] = this.state.drawColor;
        } else if(this.state.tool === 'eraser') {
            delete this.mods[c+','+r];
        } else if(this.state.tool === 'picker') {
            // Find logic color
            if(this.mods[c+','+r]) {
                this.state.drawColor = this.mods[c+','+r];
            } else {
                // Find in clusters
                var match = this.clusters.find(function(cl){ return cl.points.some(function(p){ return p.c===c && p.r===r; }); });
                if(match) this.state.drawColor = match.customHex || match.hex;
            }
            document.getElementById('draw-color').value = this.state.drawColor;
            this.setTool('pen');
        }
        this.render();
    };

    // --- Community Logic ---
    this.saveToCommunity = function() {
        if(!this.grid.ready || this.clusters.length === 0) {
            this.toast("è¯·å…ˆè¿›è¡Œåˆ†æç”Ÿæˆå›¾çº¸");
            return;
        }
        var name = prompt("ä¸ºå›¾çº¸å‘½å:", "æˆ‘çš„æ‹¼è±†å›¾çº¸ " + new Date().toLocaleDateString());
        if(!name) return;
        
        // Generate pixel art thumbnail (clean)
        var pxCanvas = document.createElement('canvas');
        pxCanvas.width = 100; pxCanvas.height = 100;
        var pctx = pxCanvas.getContext('2d');
        pctx.fillStyle = "#111"; pctx.fillRect(0,0,100,100);
        
        // Find bounds
        var minC=9999, minR=9999, maxC=-9999, maxR=-9999;
        this.clusters.forEach(function(cl){
            cl.points.forEach(function(p){
                minC = Math.min(minC, p.c); minR = Math.min(minR, p.r);
                maxC = Math.max(maxC, p.c); maxR = Math.max(maxR, p.r);
            });
        });
        
        var cw = maxC - minC + 1;
        var ch = maxR - minR + 1;
        var s = Math.min(100/cw, 100/ch);
        var ox = (100 - cw*s)/2;
        var oy = (100 - ch*s)/2;
        
        this.clusters.forEach(function(cl){
            pctx.fillStyle = cl.customHex || cl.hex;
            cl.points.forEach(function(p){
                pctx.fillRect(ox + (p.c-minC)*s, oy + (p.r-minR)*s, s, s);
            });
        });
        var pixelThumb = pxCanvas.toDataURL();
        
        // Generate Image thumbnail (if image exists)
        var imgThumb = "";
        if(this.state.img) {
            var iCanvas = document.createElement('canvas'); iCanvas.width=100; iCanvas.height=100;
            var ictx = iCanvas.getContext('2d');
            var is = Math.min(100/this.state.img.width, 100/this.state.img.height);
            ictx.drawImage(this.state.img, 0,0, this.state.img.width*is, this.state.img.height*is);
            imgThumb = iCanvas.toDataURL();
        }

        var totalBeads = 0;
        this.clusters.forEach(function(c){ totalBeads += c.points.length; });
        
        var blueprint = {
            id: Date.now(),
            title: name,
            date: new Date().toLocaleDateString(),
            grid: this.grid,
            phys: this.phys,
            // Deep copy clusters to save points
            clusters: JSON.parse(JSON.stringify(this.clusters)),
            mods: JSON.parse(JSON.stringify(this.mods)),
            imgThumb: imgThumb,
            pixelThumb: pixelThumb,
            totalBeads: totalBeads
        };
        
        var saved = JSON.parse(localStorage.getItem('perler_community_v2') || "[]");
        saved.unshift(blueprint);
        localStorage.setItem('perler_community_v2', JSON.stringify(saved));
        this.toast("å‘å¸ƒæˆåŠŸï¼");
        this.loadCommunity();
    };

    this.toggleCommThumbMode = function() {
        this.state.commThumbMode = (this.state.commThumbMode === 'image' ? 'pixel' : 'image');
        var btn = document.getElementById('btn-comm-mode');
        btn.innerText = (this.state.commThumbMode === 'image' ? "å°é¢ï¼šåŸå›¾" : "å°é¢ï¼šåƒç´ å›¾");
        this.loadCommunity();
    };

    this.loadCommunity = function() {
        var list = document.getElementById('community-list');
        list.innerHTML = "";
        var saved = JSON.parse(localStorage.getItem('perler_community_v2') || "[]");
        
        if(saved.length === 0) {
            list.innerHTML = "<div style='color:#666; text-align:center; padding:20px;'>æš‚æ— å›¾çº¸ï¼Œè¯·å…ˆåˆ¶ä½œå¹¶å‘å¸ƒ</div>";
            return;
        }

        var self = this;
        var usePixel = (this.state.commThumbMode === 'pixel');
        
        saved.forEach(function(bp){
            var card = document.createElement('div');
            card.className = "comm-card";
            var thumb = (usePixel || !bp.imgThumb) ? bp.pixelThumb : bp.imgThumb;
            
            var colorHtml = "";
            bp.clusters.slice(0,5).forEach(function(c){
                colorHtml += '<div class="comm-c-dot" style="background:'+(c.customHex||c.hex)+'" title="'+c.id+'"></div>';
            });

            card.innerHTML = `
                <img src="${thumb}" class="comm-thumb">
                <div class="comm-info">
                    <div>
                        <div class="comm-title">${bp.title}</div>
                        <div class="comm-stats">${bp.date} Â· å…± ${bp.totalBeads} é¢—</div>
                        <div class="comm-colors">${colorHtml}</div>
                    </div>
                </div>
            `;
            card.onclick = function() { self.loadBlueprint(bp); };
            list.appendChild(card);
        });
    };

    this.loadBlueprint = function(bp) {
        this.grid = bp.grid;
        this.phys = bp.phys;
        this.clusters = bp.clusters;
        this.mods = bp.mods || {};
        this.state.img = null; // No image source
        this.tmpCanvas = null;
        
        // Force settings for grid-only viewing
        this.state.mode = 'play';
        document.getElementById('t-rect').classList.add('active'); // Matrix on
        document.getElementById('t-tex').classList.remove('active'); // Texture off
        
        // Reset View
        var minC=9999, maxC=-9999, minR=9999, maxR=-9999;
        this.clusters.forEach(function(c){
             c.points.forEach(function(p){
                 minC=Math.min(minC,p.c); maxC=Math.max(maxC,p.c);
                 minR=Math.min(minR,p.r); maxR=Math.max(maxR,p.r);
             });
        });
        
        var cw = (maxC - minC + 1) * this.grid.pitch;
        var ch = (maxR - minR + 1) * this.grid.pitch;
        var vw = this.vp.offsetWidth, vh = this.vp.offsetHeight;
        var s = Math.min((vw-40)/cw, (vh-40)/ch);
        
        this.state.view.scale = s;
        // Center around the content (approx)
        // Since we don't have image width/height, we rely on grid extents
        this.state.view.x = (vw - cw*s)/2 - (minC * this.grid.pitch * s);
        this.state.view.y = (vh - ch*s)/2 - (minR * this.grid.pitch * s);
        
        this.setMode('play');
        this.renderPaletteGroups();
        this.render();
        this.toast("å›¾çº¸å·²åŠ è½½");
    };
    // ----------------------

    // Fix 3: Smart Jump Logic
    this.jumpCellSize = function(direction) {
        if(!this.markers[0] || !this.markers[1]) {
            this.stepInput('val-cell-size', direction * 0.1);
            app.manualGrid();
            return;
        }
        
        var m1 = this.markers[0];
        var m2 = this.markers[1];
        var dx = Math.abs(m2.cx - m1.cx);
        var dy = Math.abs(m2.cy - m1.cy);
        var dist = Math.max(dx, dy); 
        
        var currentSize = parseFloat(this.getVal('val-cell-size')) || 10;
        var currentPitch = currentSize; // Gap is 0
        
        var currentCount = dist / currentPitch;
        
        var nextCount;
        if (direction > 0) {
            nextCount = Math.floor(currentCount - 0.1);
        } else {
            nextCount = Math.ceil(currentCount + 0.1);
        }
        
        if (nextCount < 1) nextCount = 1;
        
        var newPitch = dist / nextCount;
        var newSize = newPitch;
        
        if(newSize < 1) newSize = 1;
        
        document.getElementById('val-cell-size').value = newSize.toFixed(2);
        this.manualGrid();
    };

    // Sampling Canvas Logic
    this.drawSampleCanvas = function() {
        if(!this.grid.ready) return;
        var cvs = document.getElementById('sample-canvas');
        cvs.width = 150; cvs.height = 150;
        var ctx = cvs.getContext('2d');
        
        var px = this.grid.pitchX || this.grid.pitch;
        var py = this.grid.pitchY || this.grid.pitch;
        
        // Use user selected cell or default to TL (0,0)
        var c = this.state.sampleCellOffset ? this.state.sampleCellOffset.c : 0;
        var r = this.state.sampleCellOffset ? this.state.sampleCellOffset.r : 0;
        
        var sx = this.grid.origin.x + c * px;
        var sy = this.grid.origin.y + r * py;
        
        ctx.fillStyle = "#000"; ctx.fillRect(0,0,150,150);
        ctx.imageSmoothingEnabled = false;
        
        if(this.state.img) {
            ctx.drawImage(this.state.img, sx, sy, px, py, 0, 0, 150, 150);
        }
        
        var rect = this.state.sampleRect;
        if(rect) {
            ctx.strokeStyle = "red";
            ctx.lineWidth = 2;
            ctx.strokeRect(rect.x*150, rect.y*150, rect.w*150, rect.h*150);
            ctx.fillStyle = "rgba(255,0,0,0.2)";
            ctx.fillRect(rect.x*150, rect.y*150, rect.w*150, rect.h*150);
        }
    };
    
    this.setSampleCellMode = function() {
        if (!this.grid.ready) {
            this.toast("è¯·å…ˆç”Ÿæˆç½‘æ ¼");
            return;
        }
        this.state.waitingForSampleCell = !this.state.waitingForSampleCell;
        if (this.state.waitingForSampleCell) {
            document.getElementById('btn-select-sample').classList.add('active');
            this.toast("è¯·åœ¨ç”»å¸ƒä¸Šç‚¹å‡»è¦ç”¨ä½œæ ¡å‡†æ ·æœ¬çš„ç½‘æ ¼");
        } else {
            document.getElementById('btn-select-sample').classList.remove('active');
        }
    };

    this.sampleStart = function(e) {
        if(!this.grid.ready) return;
        var r = e.target.getBoundingClientRect();
        this.state.sampleDraw = { active:true, x: e.clientX-r.left, y: e.clientY-r.top };
    };
    this.sampleMove = function(e) {
        if(!this.state.sampleDraw.active) return;
        var r = e.target.getBoundingClientRect();
        var curX = Math.max(0, Math.min(150, e.clientX-r.left));
        var curY = Math.max(0, Math.min(150, e.clientY-r.top));
        
        var x = Math.min(this.state.sampleDraw.x, curX);
        var y = Math.min(this.state.sampleDraw.y, curY);
        var w = Math.abs(curX - this.state.sampleDraw.x);
        var h = Math.abs(curY - this.state.sampleDraw.y);
        
        this.state.sampleRect = {x:x/150, y:y/150, w:w/150, h:h/150};
        this.drawSampleCanvas();
    };
    this.sampleEnd = function(e) {
        this.state.sampleDraw.active = false;
        if(this.state.sampleRect && (this.state.sampleRect.w < 0.05 || this.state.sampleRect.h < 0.05)) {
            this.state.sampleRect = null; 
            this.drawSampleCanvas();
        }
    };
    this.resetSampleRect = function() {
        this.state.sampleRect = null;
        this.drawSampleCanvas();
    };
    
    this.stepInput = function(id, d) {
        var el = document.getElementById(id);
        var v = parseFloat(el.value) || 0;
        var step = parseFloat(el.getAttribute('step')) || 1;
        var min = parseFloat(el.getAttribute('min'));
        var newVal = v + d;
        if(!isNaN(min) && newVal < min) newVal = min;
        el.value = newVal.toFixed(d % 1 !== 0 ? 1 : 0);
    };
    
    this.toggleSidebar = function() {
        this.state.isSidebarOpen = !this.state.isSidebarOpen;
        var sb = document.getElementById('sidebar');
        if(this.state.isSidebarOpen) sb.classList.remove('collapsed');
        else sb.classList.add('collapsed');
    };

    this.toggleSidebarSide = function() {
        var sb = document.getElementById('sidebar');
        if(sb.classList.contains('left')) {
            sb.classList.remove('left');
            sb.classList.add('right');
        } else {
            sb.classList.remove('right');
            sb.classList.add('left');
        }
    };
    
    this.togglePaletteMode = function() {
        this.state.paletteMode = (this.state.paletteMode === 'image' ? 'color' : 'image');
        var btn = document.getElementById('btn-pal-mode');
        btn.innerText = (this.state.paletteMode === 'image' ? "æ˜¾ç¤ºï¼šåŸå›¾æˆªå›¾" : "æ˜¾ç¤ºï¼šè¯†åˆ«é¢œè‰²");
        this.renderPaletteGroups();
    };

    this.flipImage = function() {
        if(!this.state.img) return;
        
        var cvs = document.createElement('canvas');
        cvs.width = this.state.img.width;
        cvs.height = this.state.img.height;
        var ctx = cvs.getContext('2d');
        ctx.translate(cvs.width, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(this.state.img, 0, 0);
        
        var newImg = new Image();
        newImg.onload = function(){
            app.state.img = newImg;
            app.clearAnalysis();
            app.state.isMirrored = !app.state.isMirrored;
            var btn = document.getElementById('btn-mirror');
            if(app.state.isMirrored) btn.classList.add('active'); else btn.classList.remove('active');
            app.tmpCanvas = null; 
            app.render();
        };
        newImg.src = cvs.toDataURL();
    };
    
    this.handleStart = function(x, y) {
        if(this.state.mode === 'play') {
            if(this.state.tool !== 'move') {
                this.state.isPainting = true;
                this.handleClick(x, y); // Paint initial
                return;
            }
            if(this.state.viewMode === 'locked') return;
        }

        this.state.drag.active = true;
        this.state.drag.lx = x;
        this.state.drag.ly = y;
        this.state.drag.moved = false;
    };
    
    this.handleMove = function(x, y) {
        if(this.state.isPainting) {
            this.handleClick(x, y); // Paint on drag
            return;
        }

        if(!this.state.drag.active) return;
        var dx = x - this.state.drag.lx;
        var dy = y - this.state.drag.ly;
        if(Math.hypot(dx,dy) > 5) {
            this.state.view.x += dx;
            this.state.view.y += dy;
            this.state.drag.lx = x;
            this.state.drag.ly = y;
            this.state.drag.moved = true;
            this.render();
        }
    };
    
    this.handleEnd = function(e) {
        this.state.isPainting = false;
        if (this.state.isPainting) this.pushHistory(); // End painting stroke
        
        this.state.drag.active = false;
        if(!this.state.drag.moved && (e.type === 'mouseup' || e.type === 'touchend')) {
            var clientX, clientY;
            if(e.changedTouches && e.changedTouches.length > 0) {
                clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY;
            } else {
                clientX = e.clientX; clientY = e.clientY;
            }
            if(e.target.closest('.sidebar') || e.target.closest('.sidebar-toggle') || e.target.closest('.view-control')) return; 
            
            this.handleClick(clientX, clientY);
        }
        this.state.pinchDist = 0;
    };
    
    this.handlePinchStart = function(e) {
        if(this.state.mode === 'play' && this.state.viewMode === 'locked') return;
        this.state.pinchDist = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY
        );
    };
    
    this.handlePinchMove = function(e) {
        if(this.state.mode === 'play' && this.state.viewMode === 'locked') return;
        var newDist = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY
        );
        if(this.state.pinchDist > 0) {
            var s = newDist / this.state.pinchDist;
            var cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
            var cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
            this.zoomAt(cx, cy, s);
            this.state.pinchDist = newDist;
        }
    };
    
    this.zoomAt = function(cx, cy, s) {
        var r = this.vp.getBoundingClientRect();
        var mx = cx - r.left;
        var my = cy - r.top;
        this.state.view.x = mx - (mx - this.state.view.x) * s;
        this.state.view.y = my - (my - this.state.view.y) * s;
        this.state.view.scale *= s;
        this.render();
    };
    
    this.handleClick = function(cx, cy) {
        var r = this.vp.getBoundingClientRect();
        var ex = cx - r.left, ey = cy - r.top;
        
        if(this.state.mode === 'calib' && this.state.waitClick) {
            this.phys.anchors[this.state.activeAnchor] = {x:ex, y:ey}; 
            this.state.waitClick = false; 
            this.savePhys(); this.render();
            document.getElementById('cal-btn-0').className = 'ghost'; 
            document.getElementById('cal-btn-1').className = 'ghost';
        } 
        else if (this.state.mode === 'analyze') {
             if (this.state.waitingForBasePoint && this.grid.ready) {
                var mx = (ex - this.state.view.x) / this.state.view.scale;
                var my = (ey - this.state.view.y) / this.state.view.scale;
                var px = this.grid.pitch;
                var py = this.grid.pitch;
                var relX = (mx - this.grid.origin.x) % px;
                if (relX < 0) relX += px;
                var relY = (my - this.grid.origin.y) % py;
                if (relY < 0) relY += py;
                if (relX < 2 || relX > px - 2 || relY < 2 || relY > py - 2) {
                    this.toast("ç‚¹å‡»åˆ°äº†ç½‘æ ¼çº¿ä¸Šï¼Œè¯·é‡è¯•"); return;
                }
                var c = Math.floor((mx - this.grid.origin.x) / px);
                var rRow = Math.floor((my - this.grid.origin.y) / py);
                this.grid.baseOffset = {c: c, r: rRow};
                this.state.waitingForBasePoint = false;
                document.getElementById('btn-base-point').classList.remove('active');
                this.toast("åŸºå‡†ç‚¹å·²æ›´æ–°");
                this.render();
            } else if (this.state.waitingForSampleCell && this.grid.ready) {
                var mx = (ex - this.state.view.x) / this.state.view.scale;
                var my = (ey - this.state.view.y) / this.state.view.scale;
                var px = this.grid.pitch;
                var c = Math.floor((mx - this.grid.origin.x) / px);
                var rRow = Math.floor((my - this.grid.origin.y) / px);
                this.state.sampleCellOffset = {c: c, r: rRow};
                this.state.waitingForSampleCell = false;
                document.getElementById('btn-select-sample').classList.remove('active');
                this.toast("æ ¡å‡†æ ·æœ¬å·²æ›´æ–°");
                this.drawSampleCanvas();
                this.render();
            } else if(this.state.targetMarker !== -1) {
                var mx = (ex - this.state.view.x) / this.state.view.scale;
                var my = (ey - this.state.view.y) / this.state.view.scale;
                if(this.state.targetMarkerFixed) {
                    if(this.state.waitingForFixedPos) {
                        this.markers[this.state.targetMarker] = { x:mx, y:my, w:6, h:6, cx:mx+3, cy:my+3, gapX:0, gapY:0, fixed:true };
                        document.getElementById('analyze-group').classList.remove('mode-smart');
                        document.getElementById('analyze-group').classList.add('mode-fixed');
                        document.getElementById('mk-btn-0').disabled = true;
                        document.getElementById('mk-btn-1').disabled = true;
                        this.state.waitingForFixedPos = false; // Lock
                        this.render();
                        this.manualGrid();
                    }
                } else {
                    this.spiralSearch(mx, my);
                    this.setTargetMarker(-1, false);
                }
            }
        } 
        else if(this.state.mode === 'play') {
            // Check for painting
            if(this.state.tool !== 'move') {
                var tl=this.phys.anchors[0], br=this.phys.anchors[1], cw=(br.x-tl.x)/this.phys.cols, ch=(br.y-tl.y)/this.phys.rows;
                var c = Math.floor((ex-tl.x)/cw);
                var r = Math.floor((ey-tl.y)/ch);
                if(c>=0 && c<this.phys.cols && r>=0 && r<this.phys.rows) {
                    // Logic coords
                    var gc = c + this.page.x * this.phys.cols;
                    var gr = r + this.page.y * this.phys.rows;
                    
                    // Mirror logic handled in rendering, but modification is on LOGICAL grid
                    // If visual is mirrored, the click 'c' corresponds to inverted logical col
                    if(this.isChecked('t-mirror')) {
                        // Visual c=0 is Logical c=cols-1 (relative to page)
                        var visC = c;
                        var relC = this.phys.cols - 1 - visC;
                        gc = relC + this.page.x * this.phys.cols;
                    }
                    
                    this.applyMod(gc, gr);
                }
            } else {
                this.handleInspector(ex, ey);
            }
        }
    };
    
    this.nudgeBoth = function(dx, dy) {
        this.phys.anchors[0].x += dx; this.phys.anchors[0].y += dy;
        this.phys.anchors[1].x += dx; this.phys.anchors[1].y += dy;
        this.savePhys(); this.render();
    };
    
    this.bindRepeater = function(id, action) {
        var el = document.getElementById(id);
        if(!el) return;
        var t;
        var start = function(e) {
            if(e.cancelable) e.preventDefault(); 
            action();
            t = setInterval(action, 100);
        };
        var stop = function() { clearInterval(t); };
        el.addEventListener('mousedown', start);
        el.addEventListener('touchstart', start, {passive:false});
        el.addEventListener('mouseup', stop);
        el.addEventListener('mouseleave', stop);
        el.addEventListener('touchend', stop);
    };

    this.savePhys = function() {
        this.phys.cols = parseInt(this.getVal('phys-cols')) || 29;
        this.phys.rows = parseInt(this.getVal('phys-rows')) || 29;
        this.phys.weight = parseFloat(this.getVal('phys-weight')) || 1;
        localStorage.setItem('perler_final_v12', JSON.stringify(this.phys));
        this.render();
    };

    this.resize = function() {
        var w = this.vp.offsetWidth, h = this.vp.offsetHeight;
        document.getElementById('layer-img').width = w; document.getElementById('layer-img').height = h;
        document.getElementById('layer-phys').width = w; document.getElementById('layer-phys').height = h;
        this.render();
    };

    this.setMode = function(m) {
        this.state.mode = m;
        var tabs = document.querySelectorAll('.tab');
        tabs[0].className = (m==='calib'?'tab active':'tab'); tabs[1].className = (m==='analyze'?'tab active':'tab'); tabs[2].className = (m==='play'?'tab active':'tab'); tabs[3].className = (m==='community'?'tab active':'tab');
        document.getElementById('panel-calib').style.display = (m==='calib'?'block':'none'); document.getElementById('panel-analyze').style.display = (m==='analyze'?'block':'none'); document.getElementById('panel-play').style.display = (m==='play'?'block':'none'); document.getElementById('panel-community').style.display = (m==='community'?'block':'none');
        document.getElementById('view-control-bar').style.display = (m==='play'?'flex':'none');
        this.render();
        if(m==='analyze') this.drawSampleCanvas();
    };

    this.selAnchor = function(i) {
        this.state.waitClick = true; this.state.activeAnchor = i;
        document.getElementById('cal-btn-0').className = (i===0?'active':'ghost'); document.getElementById('cal-btn-1').className = (i===1?'active':'ghost');
    };

    this.nudge = function(dx, dy) {
        var a = this.phys.anchors[this.state.activeAnchor]; a.x += dx; a.y += dy; this.savePhys(); this.render();
    };

    this.setTargetMarker = function(i, isFixed) {
        if(!this.state.img) {
            this.toast("è¯·å…ˆä¸Šä¼ åº•å›¾å›¾åƒ");
            return;
        }

        if (this.markers.length > 0) {
            var existingMode = this.markers[0].fixed ? true : false;
            if (existingMode !== isFixed) return; 
        }

        this.state.targetMarker = i; this.state.targetMarkerFixed = isFixed;
        
        if(isFixed) {
            this.state.activeFixedMarker = i;
            this.state.waitingForFixedPos = true;
        }

        var smartBtns = ['mk-btn-0', 'mk-btn-1'];
        var fixedBtns = ['mk-btn-fixed-0', 'mk-btn-fixed-1'];
        var isFirstSet = (this.markers.length === 0);
        
        if (isFirstSet || (this.markers[0].fixed === isFixed)) {
             [].concat(smartBtns, fixedBtns).forEach(function(id){
                var el = document.getElementById(id);
                if (id === (isFixed ? 'mk-btn-fixed-'+i : 'mk-btn-'+i)) {
                    el.className = 'active';
                } else {
                    el.className = '';
                }
             });
        }
        
        if (!isFirstSet) {
             var btnsToDisable = isFixed ? smartBtns : fixedBtns;
             btnsToDisable.forEach(function(id){ document.getElementById(id).disabled = true; });
        }
    };
    
    this.nudgeFixed = function(dx, dy) {
        if(this.state.activeFixedMarker === -1 || !this.markers[this.state.activeFixedMarker]) return;
        var m = this.markers[this.state.activeFixedMarker];
        m.x += dx * 0.5; m.y += dy * 0.5;
        m.cx += dx * 0.5; m.cy += dy * 0.5;
        this.manualGrid();
        this.render();
    };

    this.clearAnalysis = function() {
        this.markers = []; this.grid.ready = false;
        this.grid.baseOffset = {c:0, r:0};
        this.state.sampleRect = null;
        this.state.sampleCellOffset = null;
        ['mk-btn-0','mk-btn-1','mk-btn-fixed-0','mk-btn-fixed-1'].forEach(function(id){
            var el = document.getElementById(id); 
            if(el) { el.disabled = false; el.className = ''; }
        });
        document.getElementById('analyze-group').className = 'group'; 
        this.state.targetMarker = -1;
        this.state.targetMarkerFixed = false;
        this.state.activeFixedMarker = -1;
        this.state.waitingForFixedPos = false;
        document.getElementById('span-x').value = 1;
        document.getElementById('span-y').value = 1;
        
        this.drawSampleCanvas(); 
        this.render();
    };

    this.spiralSearch = function(cx, cy) {
        var tol = parseInt(this.getVal('cross-tol')) || 30;
        var side=1, x=0, y=0, dx=1, dy=0, steps=0;
        for (var i=0; i<400; i++) {
            var b = this.detectBlock(cx+x, cy+y, tol);
            if(b) { 
                this.markers[this.state.targetMarker] = b;
                document.getElementById('analyze-group').classList.add('mode-smart');
                document.getElementById('mk-btn-fixed-0').disabled = true;
                document.getElementById('mk-btn-fixed-1').disabled = true;

                if (this.markers[0] && this.markers[1]) {
                    this.autoCalcGridSmart();
                } else {
                    this.grid.ready = false; 
                }

                this.render(); return; 
            }
            if(steps === side){ steps=0; var t=dx; dx=-dy; dy=t; if(dy===0)side++; }
            x+=dx; y+=dy; steps++;
        }
        this.toast("æœªå‘ç°åˆè§„åƒç´ å—");
    };

    this.detectBlock = function(cx, cy, tol) {
        var ctx = this.getTmpCtx(); if(!ctx) return null;
        var w = this.state.img.width, h = this.state.img.height, d = ctx.getImageData(0,0,w,h).data;
        var ix=Math.floor(cx), iy=Math.floor(cy); if(ix<0||iy<0||ix>=w||iy>=h) return null;
        var i0=(iy*w+ix)*4, c0=[d[i0], d[i0+1], d[i0+2]];
        var isM = function(x,y){ if(x<0||y<0||x>=w||y>=h)return false; var i=(y*w+x)*4; return (Math.abs(d[i]-c0[0])+Math.abs(d[i+1]-c0[1])+Math.abs(d[i+2]-c0[2]))<tol; };
        var l=ix, r=ix, t=iy, b=iy;
        while(isM(l-1,iy)) l--; while(isM(r+1,iy)) r++; while(isM(ix,t-1)) t--; while(isM(ix,b+1)) b++;
        var bw = r-l+1, bh = b-t+1;
        if (Math.abs(bw - bh) > 2 || bw < 4) return null;

        if (this.state.targetMarker === 1 && this.markers[0]) {
            var m1 = this.markers[0];
            if (Math.abs(bw - m1.w) > m1.w * 0.2 || Math.abs(bh - m1.h) > m1.h * 0.2) return null; 
        }

        return { x:l, y:t, w:bw, h:bh, cx:(l+r)/2, cy:(t+b)/2, gapX:0, gapY:0, fixed:false };
    };
    
    this.autoCalcGridSmart = function() {
        if(!this.markers[0] || !this.markers[1]) return;
        
        var m1 = this.markers[0];
        var m2 = this.markers[1];
        var avgSize = (m1.w + m2.w) / 2; 
        
        var startX = Math.round(m1.cx + m1.w/2 + 1);
        var detectedGap = 0; // Fix 60: Default gap 0

        var elSize = document.getElementById('val-cell-size');
        var elGap = document.getElementById('val-gap');
        if(elSize) elSize.value = avgSize.toFixed(1);
        if(elGap) elGap.value = detectedGap.toFixed(1);
        
        this.manualGrid();
    };

    this.manualGrid = function() {
        if(!this.markers[0]) return;
        var m1 = this.markers[0];
        
        if(m1.fixed) {
            if(!this.markers[1]) return;
            var m2 = this.markers[1];
            var spanX = parseInt(this.getVal('span-x')) || 1;
            var spanY = parseInt(this.getVal('span-y')) || 1;
            var distW = Math.abs(m2.x - m1.x);
            var distH = Math.abs(m2.y - m1.y);
            var pitchX = distW / spanX;
            var pitchY = distH / spanY;
            var pitch = (pitchX + pitchY) / 2; 
            var cell = pitch;
            
            this.grid = { ready:true, pitch:pitch, gap:0, cell:cell, origin:{x:m1.x, y:m1.y}, fixed: true, pitchX: pitchX, pitchY: pitchY, baseOffset:this.grid.baseOffset };
        } else {
            if (!this.markers[1]) {
                this.grid.ready = false; 
                this.render();
                return;
            }
            var cellSize = parseFloat(this.getVal('val-cell-size')) || 10;
            // Gap removed from UI, keeping internal logic compatible
            
            var pitch = cellSize;
            var ox = m1.cx - pitch/2;
            var oy = m1.cy - pitch/2;
            this.grid = { ready:true, pitch:pitch, gap:0, cell:cellSize, origin:{x:ox, y:oy}, fixed: false, pitchX: pitch, pitchY: pitch, baseOffset:this.grid.baseOffset };
        }
        
        this.drawSampleCanvas();
        this.render();
    };
    
    this.stepCellSize = function(d) {
        var el = document.getElementById('val-cell-size');
        var v = parseFloat(el.value) || 10;
        el.value = (v + d).toFixed(1);
        this.manualGrid();
    };

    this.changePage = function(dx, dy) {
        if(!this.grid.ready || !this.state.img) return;
        var px = this.grid.pitchX || this.grid.pitch;
        var py = this.grid.pitchY || this.grid.pitch;
        var w = this.state.img.width;
        var h = this.state.img.height;
        var bc = this.grid.baseOffset ? this.grid.baseOffset.c : 0;
        var br = this.grid.baseOffset ? this.grid.baseOffset.r : 0;
        
        var minPageX = Math.floor(-bc / this.phys.cols);
        var imgCols = Math.ceil(w / px);
        var maxPageX = Math.ceil((imgCols - bc) / this.phys.cols);
        
        var minPageY = Math.floor(-br / this.phys.rows);
        var imgRows = Math.ceil(h / py);
        var maxPageY = Math.ceil((imgRows - br) / this.phys.rows);

        this.page.x = Math.min(maxPageX, Math.max(minPageX, this.page.x + dx));
        this.page.y = Math.min(maxPageY, Math.max(minPageY, this.page.y + dy));
        document.getElementById('page-display').innerText = "åŒºåŸŸ [" + this.page.x + "," + this.page.y + "]";
        
        this.renderPaletteGroups();
        this.render();
    };

    this.render = function() {
        var self = this; var pCtx = this.ctx.phys;
        Object.keys(this.ctx).forEach(function(k){ self.ctx[k].clearRect(0,0,self.vp.offsetWidth, self.vp.offsetHeight); });
        if(this.state.mode === 'calib') { this.drawPhysGrid(); }
        else if(this.state.mode === 'analyze' && this.state.img) {
            var imgL = this.ctx.img; imgL.save(); imgL.translate(this.state.view.x, this.state.view.y); imgL.scale(this.state.view.scale, this.state.view.scale);
            imgL.drawImage(this.state.img, 0, 0);
            this.markers.forEach(function(m, i){ 
                imgL.fillStyle = (i===0 ? "rgba(0, 200, 0, 0.8)" : "rgba(0, 255, 150, 0.8)");
                imgL.fillRect(m.x, m.y, m.w, m.h); 
            });
            if(this.grid.ready){
                imgL.beginPath(); 
                imgL.lineWidth = parseInt(this.getVal('grid-width')) || 2;
                imgL.strokeStyle = this.getVal('grid-color-an') || '#00ff00'; 
                
                var px = this.grid.pitchX || this.grid.pitch;
                var py = this.grid.pitchY || this.grid.pitch;
                
                var w = this.state.img.width;
                var h = this.state.img.height;
                
                var startX = this.grid.origin.x % px;
                if (startX < 0) startX += px;
                
                for(var gx = startX; gx <= w; gx += px) {
                    imgL.moveTo(gx, 0); imgL.lineTo(gx, h);
                }
                
                var startY = this.grid.origin.y % py;
                if (startY < 0) startY += py;
                
                for(var gy = startY; gy <= h; gy += py) {
                    imgL.moveTo(0, gy); imgL.lineTo(w, gy);
                }
                
                imgL.stroke(); 

                if (this.grid.baseOffset) {
                    var bx = this.grid.origin.x + this.grid.baseOffset.c * px;
                    var by = this.grid.origin.y + this.grid.baseOffset.r * py;
                    imgL.beginPath(); 
                    imgL.fillStyle = "rgba(255, 0, 0, 0.3)";
                    imgL.fillRect(bx, by, px, py);
                    imgL.strokeStyle = "red";
                    imgL.lineWidth = 2; 
                    imgL.strokeRect(bx, by, px, py);
                }
                
                if (this.state.sampleCellOffset) {
                    var sx = this.grid.origin.x + this.state.sampleCellOffset.c * px;
                    var sy = this.grid.origin.y + this.state.sampleCellOffset.r * py;
                    imgL.beginPath(); 
                    imgL.fillStyle = "rgba(0, 100, 255, 0.3)";
                    imgL.fillRect(sx, sy, px, py);
                    imgL.strokeStyle = "#0064ff";
                    imgL.lineWidth = 2; 
                    imgL.strokeRect(sx, sy, px, py);
                }
            }
            imgL.restore();
        }
        else if(this.state.mode === 'play') {
            var bg = this.getVal('bg-color') || "#111"; pCtx.fillStyle = bg; pCtx.fillRect(0,0,this.vp.offsetWidth, this.vp.offsetHeight);
            this.drawClusters(bg); this.drawPhysGrid();
        }
    };

    this.drawPhysGrid = function() {
        var self=this, pCtx = this.ctx.phys, tl=this.phys.anchors[0], br=this.phys.anchors[1], cw=(br.x-tl.x)/this.phys.cols, ch=(br.y-tl.y)/this.phys.rows;
        pCtx.strokeStyle = (this.state.mode==='calib'?'#0F0':this.getVal('grid-color'));
        pCtx.lineWidth = this.phys.weight || 1;
        pCtx.beginPath();
        for(var i=0; i<=this.phys.cols; i++){ pCtx.moveTo(tl.x+i*cw, tl.y); pCtx.lineTo(tl.x+i*cw, br.y); }
        for(var i=0; i<=this.phys.rows; i++){ pCtx.moveTo(tl.x, tl.y+i*ch); pCtx.lineTo(br.x, tl.y+i*ch); }
        pCtx.stroke();
        this.phys.anchors.forEach(function(a,i){
            pCtx.fillStyle = (self.state.mode==='calib' && i===self.state.activeAnchor?'#FFF':'#0F0');
            pCtx.fillRect(a.x-1, a.y-1, 2, 2); pCtx.font = "bold 11px Arial";
            if(i===0) { pCtx.fillText("TL", a.x-6, a.y-8); } else { pCtx.fillText("BR", a.x-6, a.y+15); }
        });
    };

    this.drawClusters = function(bg) {
        var self=this, pCtx=this.ctx.phys, tl=this.phys.anchors[0], br=this.phys.anchors[1], cw=(br.x-tl.x)/this.phys.cols, ch=(br.y-tl.y)/this.phys.rows;
        var isR=this.isChecked('t-rect'), op=parseInt(this.getVal('shape-outer'))/100, ip=parseInt(this.getVal('shape-inner'))/100, st=this.isChecked('t-tex');
        var useCustomHL = this.isChecked('t-hl');
        var customColor = this.getVal('custom-hl-color');
        var isMirrored = this.isChecked('t-mirror');
        
        var px = this.grid.pitchX || this.grid.pitch;
        var py = this.grid.pitchY || this.grid.pitch;
        var baseC = this.grid.baseOffset ? this.grid.baseOffset.c : 0;
        var baseR = this.grid.baseOffset ? this.grid.baseOffset.r : 0;

        // Draw Analyzed Data
        this.clusters.forEach(function(cl, idx) {
            if(self.activeClusterIdx!==-1 && self.activeClusterIdx!==idx) return;
            cl.points.forEach(function(p){
                var modKey = p.c+','+p.r;
                // Skip if modified, will draw later
                if(self.mods[modKey]) return;

                var relC = (p.c - baseC) - self.page.x * self.phys.cols;
                var relR = (p.r - baseR) - self.page.y * self.phys.rows;
                
                if(relC >= 0 && relC < self.phys.cols && relR >= 0 && relR < self.phys.rows) {
                    var drawC = isMirrored ? (self.phys.cols - 1 - relC) : relC;
                    var x=tl.x+drawC*cw+cw/2, y=tl.y+relR*ch+ch/2;
                    var rB = Math.min(cw,ch)/2;
                    
                    pCtx.save(); pCtx.beginPath();
                    if(isR) pCtx.rect(x-cw*op/2, y-ch*op/2, cw*op, ch*op); else pCtx.arc(x,y,rB*op,0,7);
                    pCtx.clip();
                    
                    if(st && self.state.img){
                        var rect = self.state.sampleRect; 
                        var sx, sy, sw, sh;
                        if(rect && self.isChecked('t-sample-rect')) {
                            sx = self.grid.origin.x + p.c*px + rect.x*px; sy = self.grid.origin.y + p.r*py + rect.y*py;
                            sw = rect.w * px; sh = rect.h * py;
                        } else {
                            sx = self.grid.origin.x + p.c*px; sy = self.grid.origin.y + p.r*py;
                            sw = self.grid.cell; sh = self.grid.cell;
                        }
                        pCtx.drawImage(self.state.img, sx, sy, sw, sh, x-cw/2, y-ch/2, cw, ch);
                    } else { 
                        var fillColor = (useCustomHL && self.activeClusterIdx === idx) ? customColor : (cl.customHex || cl.hex || '#666');
                        pCtx.fillStyle = fillColor; 
                        pCtx.fillRect(x-cw/2, y-ch/2, cw, ch); 
                    }
                    pCtx.restore();
                    if(ip>0){ pCtx.fillStyle=bg; pCtx.beginPath(); pCtx.arc(x,y,rB*ip,0,7); pCtx.fill(); }
                }
            });
        });

        // Draw Modifications (User Paint)
        Object.keys(this.mods).forEach(function(key){
            var parts = key.split(',');
            var c = parseInt(parts[0]), r = parseInt(parts[1]);
            var color = self.mods[key];
            
            var relC = (c - baseC) - self.page.x * self.phys.cols;
            var relR = (r - baseR) - self.page.y * self.phys.rows;
            
            if(relC >= 0 && relC < self.phys.cols && relR >= 0 && relR < self.phys.rows) {
                 var drawC = isMirrored ? (self.phys.cols - 1 - relC) : relC;
                 var x=tl.x+drawC*cw+cw/2, y=tl.y+relR*ch+ch/2;
                 var rB = Math.min(cw,ch)/2;
                 
                 pCtx.save(); pCtx.beginPath();
                 if(isR) pCtx.rect(x-cw*op/2, y-ch*op/2, cw*op, ch*op); else pCtx.arc(x,y,rB*op,0,7);
                 pCtx.clip();
                 pCtx.fillStyle = color;
                 pCtx.fillRect(x-cw/2, y-ch/2, cw, ch);
                 pCtx.restore();
                 if(ip>0){ pCtx.fillStyle=bg; pCtx.beginPath(); pCtx.arc(x,y,rB*ip,0,7); pCtx.fill(); }
            }
        });
    };

    this.analyzeFeatures = async function() {
        if(!this.grid.ready) return;
        
        var modal = document.getElementById('progress-modal');
        var bar = document.getElementById('progress-fill');
        var txt = document.getElementById('progress-info');
        modal.style.display = 'flex';
        
        var useOcr = this.isChecked('t-ocr');
        txt.innerText = useOcr ? "åˆå§‹åŒ–åˆ†æå¼•æ“..." : "æ­£åœ¨è¿›è¡Œè‰²å½©åˆ†æ...";

        var clusters = [], self = this;
        var deTol = parseFloat(this.getVal('tol-deltae'));
        
        var sampleMode = document.getElementById('algo-mode').value;
        var useRect = this.isChecked('t-sample-rect') && this.state.sampleRect;
        
        var worker = null;
        if(useOcr) {
            worker = await Tesseract.createWorker('eng');
            await worker.setParameters({ tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', tessedit_pageseg_mode: '7' });
        }
        
        var px = this.grid.pitchX || this.grid.pitch;
        var py = this.grid.pitchY || this.grid.pitch;
        var points = [];
        
        var startC = Math.floor(-this.grid.origin.x / px);
        var endC = Math.ceil((this.state.img.width - this.grid.origin.x) / px);
        var startR = Math.floor(-this.grid.origin.y / py);
        var endR = Math.ceil((this.state.img.height - this.grid.origin.y) / py);

        for(var r=startR; r<endR; r++) for(var c=startC; c<endC; c++) {
            var cx = this.grid.origin.x + c*px + px/2;
            var gy = this.grid.origin.y + r*py + py/2;
            if(cx >= 0 && cx < this.state.img.width && gy >= 0 && gy < this.state.img.height) {
                points.push({c:c, r:r, cx:cx, cy:gy});
            }
        }
        
        var total = points.length;
        var validPattern = /^[A-Z][0-9]{1,2}$/;
        var ocrCanvas = document.createElement('canvas'); ocrCanvas.width=60; ocrCanvas.height=60;
        var ocrCtx = ocrCanvas.getContext('2d');
        
        for(var i=0; i<total; i++) {
            var p = points[i];
            
            if(i%10 === 0) {
                bar.style.width = Math.round((i/total)*100) + '%';
                txt.innerText = "åˆ†æä¸­... " + i + "/" + total;
                await new Promise(r => setTimeout(r, useOcr ? 0 : 0));
            }
            
            var feat;
            var rect = useRect ? this.state.sampleRect : {x:0, y:0, w:1, h:1};
            
            if(sampleMode === '4-corner') feat = this.extractFeatCorners(p.c, p.r, px, py, rect);
            else if(sampleMode === '4-edge') feat = this.extractFeatEdges(p.c, p.r, px, py, rect);
            else if(sampleMode === '8-point') feat = this.extractFeat8Points(p.c, p.r, px, py, rect);
            else if(sampleMode.includes('-point')) feat = this.extractFeatPoints(p.c, p.r, px, py, rect, parseInt(sampleMode));
            else feat = this.extractFeatRect(p.c, p.r, px, py, rect); 
            
            if(!feat) continue;
            
            var finalId = feat.id;
            var finalHex = feat.hex;
            
            if(useOcr) {
                var tempCvs = document.createElement('canvas'); tempCvs.width=60; tempCvs.height=60;
                var tctx = tempCvs.getContext('2d'); tctx.drawImage(feat.rawCanvas, 0,0);
                var preUrl = ColorTool.preprocessForOCR(tempCvs);
                
                try {
                    var res = await worker.recognize(preUrl);
                    var rawText = res.data.text.replace(/\s+/g, '').toUpperCase();
                    if(validPattern.test(rawText)) {
                        var match = BEAD_DATA.find(function(b){ return b[0] === rawText; });
                        if(match) {
                             finalId = rawText;
                             finalHex = match[1];
                             var newLab = ColorTool.rgb2lab(this.hexToRgb(match[1]));
                             feat.lab = newLab; 
                        }
                    }
                } catch(e) {}
            }

            feat.id = finalId;
            feat.hex = finalHex;
            
            var m = clusters.find(function(cl){
                if (cl.id === feat.id) return true;
                return ColorTool.deltaE(cl.lab, feat.lab) < deTol;
            });
            
            if(m) {
                m.points.push({c:p.c, r:p.r});
            } else {
                feat.points = [{c:p.c, r:p.r}];
                clusters.push(feat);
            }
        }
        
        if(worker) await worker.terminate();

        this.clusters = clusters.sort(function(a,b){return b.points.length-a.points.length;});
        this.mods = {}; // Clear manual mods on re-analyze
        this.history = [];
        
        modal.style.display = 'none';
        this.renderPaletteGroups(); 
        this.render();
        this.toast("å…¨å›¾åˆ†æå®Œæˆ");
    };

    // Helper: Filter 25% Outliers
    this.getCleanAvg = function(pixelData) {
        var pixels = [];
        var rSum=0, gSum=0, bSum=0;
        
        for(var i=0; i<pixelData.length; i+=4) {
            pixels.push({r:pixelData[i], g:pixelData[i+1], b:pixelData[i+2]});
            rSum += pixelData[i]; gSum += pixelData[i+1]; bSum += pixelData[i+2];
        }
        
        if(pixels.length === 0) return null;
        
        var avgR = rSum / pixels.length;
        var avgG = gSum / pixels.length;
        var avgB = bSum / pixels.length;
        
        pixels.forEach(function(p){
            p.dist = Math.sqrt(Math.pow(p.r-avgR,2) + Math.pow(p.g-avgG,2) + Math.pow(p.b-avgB,2));
        });
        
        pixels.sort(function(a,b){ return a.dist - b.dist; });
        var keepCount = Math.floor(pixels.length * 0.75);
        if(keepCount < 1) keepCount = pixels.length;
        
        rSum=0; gSum=0; bSum=0;
        for(var i=0; i<keepCount; i++){
            rSum+=pixels[i].r; gSum+=pixels[i].g; bSum+=pixels[i].b;
        }
        
        return {r:rSum/keepCount, g:gSum/keepCount, b:bSum/keepCount};
    };

    this.extractFeatRect = function(c, r, px, py, rect) {
        var ctx = this.getTmpCtx();
        var x0 = this.grid.origin.x + c*px + rect.x*px;
        var y0 = this.grid.origin.y + r*py + rect.y*py;
        var w = rect.w * px;
        var h = rect.h * py;
        
        if(x0<0 || y0<0 || x0+w>this.state.img.width || y0+h>this.state.img.height) return null;
        
        var d = ctx.getImageData(x0, y0, w, h).data;
        var clean = this.getCleanAvg(d);
        if(!clean) return null;
        
        return this.matchColor(clean.r, clean.g, clean.b, c, r, px, py);
    };

    this.extractFeatCorners = function(c, r, px, py, rect) {
        return this.extractFeatPoints(c, r, px, py, rect, 4, 'corner');
    };
    
    this.extractFeatEdges = function(c, r, px, py, rect) {
        return this.extractFeatPoints(c, r, px, py, rect, 4, 'edge');
    };
    
    this.extractFeat8Points = function(c, r, px, py, rect) {
        return this.extractFeatPoints(c, r, px, py, rect, 8, 'mixed');
    };

    this.extractFeatPoints = function(c, r, px, py, rect, count, mode) {
        var ctx = this.getTmpCtx();
        var x0 = this.grid.origin.x + c*px + rect.x*px;
        var y0 = this.grid.origin.y + r*py + rect.y*py;
        var w = rect.w * px;
        var h = rect.h * py;
        
        var pts = [];
        
        if(mode === 'corner') {
             pts.push({x:x0, y:y0}, {x:x0+w-1, y:y0}, {x:x0, y:y0+h-1}, {x:x0+w-1, y:y0+h-1});
        } else if (mode === 'edge') {
             pts.push({x:x0+w/2, y:y0}, {x:x0+w/2, y:y0+h-1}, {x:x0, y:y0+h/2}, {x:x0+w-1, y:y0+h/2});
        } else if (mode === 'mixed') {
             pts.push({x:x0, y:y0}, {x:x0+w-1, y:y0}, {x:x0, y:y0+h-1}, {x:x0+w-1, y:y0+h-1});
             pts.push({x:x0+w/2, y:y0}, {x:x0+w/2, y:y0+h-1}, {x:x0, y:y0+h/2}, {x:x0+w-1, y:y0+h/2});
        } else {
             var step = Math.sqrt(count);
             for(var i=0; i<step; i++) {
                 for(var j=0; j<step; j++) {
                     pts.push({ x: x0 + (w * (i+0.5)/step), y: y0 + (h * (j+0.5)/step) });
                 }
             }
        }

        var pixelData = [];
        for(var i=0; i<pts.length; i++) {
            var p = pts[i];
            if(p.x>=0 && p.y>=0 && p.x<this.state.img.width && p.y<this.state.img.height) {
                var d = ctx.getImageData(p.x, p.y, 1, 1).data;
                pixelData.push(d[0], d[1], d[2], 255);
            }
        }
        
        var clean = this.getCleanAvg(pixelData);
        if(!clean) return null;
        
        return this.matchColor(clean.r, clean.g, clean.b, c, r, px, py);
    };

    this.matchColor = function(avgR, avgG, avgB, c, r, px, py) {
        var rgb=[avgR, avgG, avgB], lab=ColorTool.rgb2lab(rgb);
        var minDE=999, best=this.beads[0];
        for(var i=0; i<this.beads.length; i++){ var de=ColorTool.deltaE(lab, this.beads[i].lab); if(de<minDE){minDE=de; best=this.beads[i];} }
        
        var cvs=document.createElement('canvas'); cvs.width=60; cvs.height=60;
        var cctx=cvs.getContext('2d');
        var cx = this.grid.origin.x + c*px; 
        var cy = this.grid.origin.y + r*py;
        cctx.drawImage(this.state.img, cx, cy, px, py, 0, 0, 60, 60);
        
        return { id:best.id, hex:best.hex, rgb:rgb, lab:lab, imgUrl:cvs.toDataURL(), rawCanvas: cvs };
    };

    this.hexToRgb = function(hex) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [0,0,0];
    };
    
    this.updateClusterColor = function(idx, val) { var cl = this.clusters[idx]; if(!cl) return; var match = BEAD_DATA.find(function(b){ return b[0] === val.toUpperCase(); }); if(match) { cl.customHex = match[1]; cl.customId = val.toUpperCase(); } else if(/^#[0-9A-F]{6}$/i.test(val)) { cl.customHex = val; cl.customId = "Custom"; } this.render(); };
    this.renderPaletteGroups = function() {
        var div=document.getElementById('palette-list'); div.innerHTML=''; var self=this;
        var baseC = this.grid.baseOffset ? this.grid.baseOffset.c : 0;
        var baseR = this.grid.baseOffset ? this.grid.baseOffset.r : 0;
        var showColor = (this.state.paletteMode === 'color');

        this.clusters.forEach(function(cl, idx) {
            var card=document.createElement('div'); card.className=(self.activeClusterIdx===idx?'p-card active':'p-card');
            var displayId = cl.customId || cl.ocrId || cl.id;
            
            var visibleCount = 0;
            cl.points.forEach(function(p){
                var relC = (p.c - baseC) - self.page.x * self.phys.cols;
                var relR = (p.r - baseR) - self.page.y * self.phys.rows;
                if(relC >= 0 && relC < self.phys.cols && relR >= 0 && relR < self.phys.rows) {
                    visibleCount++;
                }
            });

            var content = '';
            if(showColor) {
                var c = cl.customHex || cl.hex;
                content = '<div class="color-preview" style="background:'+c+'"></div>';
            } else {
                content = '<img src="'+cl.imgUrl+'">';
            }

            card.innerHTML = content + '<input type="text" value="'+displayId+'"><div class="p-count">'+visibleCount+' / '+cl.points.length+'</div>';
            card.querySelector('input').onchange = function(e){ self.updateClusterColor(idx, e.target.value); };
            card.onclick=function(e){ if(e.target.tagName==='INPUT') return; self.activeClusterIdx=(self.activeClusterIdx===idx?-1:idx); self.render(); self.renderPaletteGroups(); };
            div.appendChild(card);
        });
    };
    this.getTmpCtx=function(){if(!this.state.img)return null; if(!this.tmpCanvas){this.tmpCanvas=document.createElement('canvas'); this.tmpCtx=this.tmpCanvas.getContext('2d',{willReadFrequently:true});} if(this.tmpCanvas.width!==this.state.img.width){this.tmpCanvas.width=this.state.img.width; this.tmpCanvas.height=this.state.img.height; this.tmpCtx.drawImage(this.state.img,0,0);} return this.tmpCtx;};
    this.handleInspector=function(ex,ey){ var tl=this.phys.anchors[0], br=this.phys.anchors[1], cw=(br.x-tl.x)/this.phys.cols, ch=(br.y-tl.y)/this.phys.rows; var c=Math.floor((ex-tl.x)/cw), r=Math.floor((ey-tl.y)/ch); if(c>=0&&c<this.phys.cols&&r>=0&&r<this.phys.rows){ var gc=c+this.page.x*this.phys.cols, gr=r+this.page.y*this.phys.rows; var match=this.clusters.find(function(cl){return cl.points.some(function(p){return p.c===gc&&p.r===gr;});}); if(match){this.toast("åæ ‡:["+gc+","+gr+"] è‰²å·:"+(match.customId||match.ocrId||match.id));} } };
    this.toast=function(m){var t=document.getElementById('toast'); t.innerText=m; t.style.display='block'; setTimeout(function(){t.style.display='none';},2000);};
    this.loadImage=function(s){return new Promise(function(res){var i=new Image(); i.onload=function(){res(i);}; i.src=s;});};
}
var app = new App();
window.onload = function(){ app.init(); };
</script>
</body>
</html>
